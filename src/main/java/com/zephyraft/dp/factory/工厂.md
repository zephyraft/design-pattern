# 工厂模式

## 应用场景
当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。
- 类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。
- 还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。

## 实现
- 简单工厂
  - 实现1：if分支判断。
  - 实现2：map key判断。
  - 可以每次new新实例，也可提前将实例缓存在map的value中。
  - 当代码中if判断与分支不是很多时，没有必要过于纠结对开闭原则的违背，使用多态或设计模式来符合开闭原则是由成本的，会增加类的个数、降低代码可读性。
- 工厂方法
  - 利用多态，每新增一种工厂要创建的类，就对应增加一种工厂类。
  - 工厂方法模式比起简单工厂模式更加符合开闭原则。
  - 引入新的问题：判断要使用哪个工厂类，又引入了新的if判断。
    - 可以再创建工厂类的简单工厂来解决。
    - 如果每个类功能很单薄，那就没必要设计成独立的类，这时候用简单工厂模式就好，不必要用工厂方法。
    - 当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，推荐使用工厂方法模式，将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂。
- 抽象工厂
  - 在简单工厂和工厂方法中，类只有一种分类方式。
  - 当有多种分类方式时，需要减少工厂类的数量。一个工厂负责创建多个不同类型的对象。

复杂度无法被消除，只能被转移：
- 不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起
- 简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中
- 工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中

## DI容器
DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。

DI 容器处理的是更大的对象创建工程，负责整个应用中所有类对象的创建

- 配置解析
  - 使用哪个构造函数以及对应的构造函数参数都是什么
- 对象创建
  - 利用反射机制，动态加载类，创建对象
- 生命周期
  - scope
    - singleton
    - prototype
  - lazy-init
  - init-method
  - destroy-method
