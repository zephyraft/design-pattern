# 单例模式

一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式。

## 应用场景

- 解决资源访问冲突
- 表示全局唯一类
   - 配置类
   - 工具类

## 实现

关注点
- 构造函数private，避免new创建实例
- 考虑对象创建时的线程安全问题
- 考虑synchronized锁性能问题
- 考虑是否支持延迟加载

实现方式
1. 饿汉式
   - 在类加载的时候，instance 静态实例就已经创建并初始化好了，所以，instance 实例的创建过程是线程安全的
2. 懒汉式
   - 支持延迟加载
   - synchronized锁粒度大，性能差
3. 双重检测（不推荐，推荐改为使用静态内部类的方式）
   - 既支持延迟加载、又支持高并发的单例
   - volatile, 避免指令重排序; java8 已经确保new、初始化为原子性操作，不会出现JIT导致指令重排的情况
   - https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html
5. 静态内部类
   - 类似饿汉式，但支持延迟加载
6. 枚举
   - 利用枚举类特性保证

## 问题
- OOP不友好
- 隐藏类之间的依赖关系
- 对扩展性不友好
- 对可测试性不友好
- 不支持有参构造函数

## 替代方案
- 静态方法
- 工厂模式
- IOC容器

## 唯一性
- 进程内唯一，对于Java，严格来说，应该是同一类加载器(ClassLoader)下唯一
   - 线程内唯一
     - 使用ConcurrentHashMap<ThreadId, Instance>维护每个线程的对象
     - ThreadLocal工具类
   - 进程间唯一
     - 使用分布式锁控制对象的获取与释放，实现同一时刻只有一个进程的一个线程在操作单例
     - 使用序列化反序列化在进程间共享实例
   - 多例
     - 享元
     - 工厂
